#LyX file created by tex2lyx 2.3
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin C:/GitHub/ai/doc/source/
\textclass article
\use_default_options false
\begin_modules
theorems-ams
graphicboxes
\end_modules
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype true
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 2
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Subsection
An Adaptive Algorithm for Solving 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
protect
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
QFK
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%
\backslash
textsc{LUCB}$(k, m)$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:adaptive"

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% Although there exist instances of 
\backslash
QFK that require within a constant factor of the sample complexity of 
\backslash
GHALVING, the algorithm is likely to be wasteful on ``easy'' instances, in which arms in $
\backslash
TOPM$ are well-separated from the remaining arms.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%We present an adaptive algorithm, 
\backslash
GLUCB, for solving $(k,m,n)$ and analyse its sample complexity.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Algorithm
\begin_inset space ~

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "alg:glucb"
plural "false"
caps "false"
noprefix "false"

\end_inset

 describes 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
GLUCB
\end_layout

\end_inset

, a fully sequential algorithm, which for 
\begin_inset Formula $k=1$
\end_inset

 has the same guarantee on sample-complexity as 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
FF
\end_layout

\end_inset

, but empirically appears to be more economical. The algorithm generalises 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
LUCB
\end_layout

\end_inset


\begin_inset space ~

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after ""
key "bib:lucb"
literal "false"

\end_inset

, which solves 
\begin_inset Formula $(m, m, n)$
\end_inset

.
\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% However, it differs from
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
LUCB in a subtle manner, due to the very definition of the problem. Like 
\backslash
QF, 
\backslash
QFK
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% assumes multiple solutions if $k < m$. On the other hand, it differs from 
\backslash
QF as it
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% can solve 
\backslash
SUBSET of size $m 
\backslash
geq 1$ for $k=m$.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{algorithm}[]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
small{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
caption{
\backslash
GLUCB: Algorithm to select $k$ $(
\backslash
epsilon, m)$-optimal arms}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
label{alg:glucb}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
DontPrintSemicolon% instead
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  
\backslash
KwIn{$
\backslash
mathcal{A}$ (
\backslash
st $|
\backslash
mathcal{A}| = n$), $k, m, 
\backslash
epsilon, 
\backslash
delta$.}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  
\backslash
KwOut{$k$ distinct $(
\backslash
epsilon,m)$-optimal arms from $
\backslash
mathcal{A}$.}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  Pull each arm $a  
\backslash
in 
\backslash
mathcal{A}$ once. Set $t = n$.
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  
\backslash
Do{$ ucb({l_*^t}, t+1) - lcb({h_*^t}, t+1) > 
\backslash
epsilon.$} { 
\backslash
label{ln:stpkoutofm}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%      $t = t + 1$.
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% %      $A_1^t = 
\backslash
{a : a' 
\backslash
in 
\backslash
mathcal{A}, 
\backslash
hatp_a = 
\backslash
hatp_{a'}
\backslash
}$ 
\backslash
st $|A_1^t| = k$.
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% %      $A_3^t = 
\backslash
{a : a' 
\backslash
in 
\backslash
mathcal{A}, 
\backslash
hatp_a = 
\backslash
hatp_{a'}
\backslash
}$ 
\backslash
st $|A_3^t| = n-m$.
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 	 $A_1^t 
\backslash
defeq $ Set of $k$ arms with the highest empirical means.
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%      $A_3^t 
\backslash
defeq $ Set of $n-m$ arms with the lowest empirical means.
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%      $A_2^t 
\backslash
defeq 
\backslash
{
\backslash
mathcal{A} 
\backslash
setminus (A_1^t 
\backslash
cup A_3^t)
\backslash
}$.
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%      $h_*^t = 
\backslash
arg 
\backslash
max_{
\backslash
{a 
\backslash
in A_1^t
\backslash
}} lcb(a,t)$.
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%      $m_*^t = 
\backslash
arg 
\backslash
min_{
\backslash
{a 
\backslash
in A_2^t
\backslash
}} u_a^{t}$.
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%      $l_*^t = 
\backslash
arg 
\backslash
max_{
\backslash
{a 
\backslash
in A_3^t
\backslash
}} ucb(a,t)$.
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%      pull  $h_*^t,  m_*^t, l_*^t$.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  
\backslash
Return $A_1^t$.
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset Float algorithm
placement ht
wide false
sideways false
status open


\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
begin{algorithmic}
\end_layout

\end_inset

 
\size small

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
{
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
REQUIRE
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
{
\end_layout

\end_inset


\begin_inset Formula $\mathcal{A}$
\end_inset

 (
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
st
\end_layout

\end_inset

 
\begin_inset Formula $|\mathcal{A}| = n$
\end_inset

), 
\begin_inset Formula $k, m, \epsilon, \delta$
\end_inset

.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
ENSURE
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
{
\end_layout

\end_inset


\begin_inset Formula $k$
\end_inset

 distinct 
\begin_inset Formula $(\epsilon,m)$
\end_inset

-optimal arms from 
\begin_inset Formula $\mathcal{A}$
\end_inset

.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
STATE
\end_layout

\end_inset

 Pull each arm 
\begin_inset Formula $a  \in \mathcal{A}$
\end_inset

 once. Set 
\begin_inset Formula $t = n$
\end_inset

. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
WHILE
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
{
\end_layout

\end_inset


\begin_inset Formula $ ucb({l_*^t}, t+1) - lcb({h_*^t}, t+1) > \epsilon.$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
{
\end_layout

\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "ln:stpkoutofm"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $t = t + 1$
\end_inset

. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $A_1^t \defeq $
\end_inset

 Set of 
\begin_inset Formula $k$
\end_inset

 arms with the highest empirical means. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $A_3^t \defeq $
\end_inset

 Set of 
\begin_inset Formula $n-m$
\end_inset

 arms with the lowest empirical means. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $A_2^t \defeq \mathcal{A} \setminus (A_1^t \cup A_3^t)$
\end_inset

. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $h_*^t = \arg \max_{\{a \in A_1^t\}} lcb(a,t)$
\end_inset

. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $m_*^t = \arg \min_{\{a \in A_2^t\}} u_a^{t}$
\end_inset

. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $l_*^t = \arg \max_{\{a \in A_3^t\}} ucb(a,t)$
\end_inset

. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
STATE
\end_layout

\end_inset

 pull 
\begin_inset Formula $h_*^t,  m_*^t, l_*^t$
\end_inset

. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
ENDWHILE
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
STATE
\end_layout

\end_inset

 Return 
\begin_inset Formula $A_1^t$
\end_inset

. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
end{algorithmic}
\end_layout

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
GLUCB
\end_layout

\end_inset

: Algorithm to select 
\begin_inset Formula $k$
\end_inset

 
\begin_inset Formula $(\epsilon, m)$
\end_inset

-optimal arms
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "alg:glucb"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
At each round 
\begin_inset Formula $t$
\end_inset

, we partition 
\begin_inset Formula $\A$
\end_inset

 into three subsets. We keep the 
\begin_inset Formula $k$
\end_inset

 arms with the highest empirical averages in 
\begin_inset Formula $A_1^t$
\end_inset

, the 
\begin_inset Formula $n-m$
\end_inset

 arms with the lowest empirical averages in 
\begin_inset Formula $A_3^t$
\end_inset

, and the rest in 
\begin_inset Formula $A_2^t$
\end_inset

; ties are broken arbitrarily (uniformly at random in our experiments). At each round we choose a 
\emph on
contentious
\emph default
 arm from each of these three sets: from 
\begin_inset Formula $A_1^t$
\end_inset

 we choose 
\begin_inset Formula $h_*^t$
\end_inset

, the arm with the lowest lower confidence bound (LCB); from 
\begin_inset Formula $A_2^t$
\end_inset

 the arm which is least pulled is chosen, and called 
\begin_inset Formula $m_*^t$
\end_inset

; from 
\begin_inset Formula $A_3^t$
\end_inset

 we choose 
\begin_inset Formula $l_*^t$
\end_inset

, the arm with the highest upper confidence bound (UCB). The algorithm stops as soon as the difference between the lower confidence bound of 
\begin_inset Formula $h_*^t$
\end_inset

, and the upper confidence bound of 
\begin_inset Formula $l_*^t$
\end_inset

 becomes no larger than the tolerance 
\begin_inset Formula $\epsilon$
\end_inset

.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $B_1, B_2, B_3$
\end_inset

 be corresponding sets based on the true means: that is, subsets of 
\begin_inset Formula $\mathcal{A}$
\end_inset

 such that 
\begin_inset Formula $B_1 \defeq \{1, 2,\cdots, k\}$
\end_inset

, 
\begin_inset Formula $B_2 = \{k+1, k+2,\cdots, m\}$
\end_inset

 and 
\begin_inset Formula $B_3=\{m+1, m+2,\cdots, n\}$
\end_inset

. For any two arms 
\begin_inset Formula $a, b \in \mathcal{A}$
\end_inset

 we define 
\begin_inset Formula $\Delta_{ab} \defeq \mu_a - \mu_b$
\end_inset

. For the sake of convenience we slightly overload this notation as 
\size footnotesize

\begin_inset Formula \begin{equation}\label{eq:defdelta}
 \Delta_a = \begin{cases}
  \mu_a - \mu_{m+1}\; \text{if}\; a \in B_1\\
  \mu_k - \mu_{m+1}\; \text{if}\; a \in B_2\\
  \mu_m - \mu_a\;\;\;\;\; \text{if}\; a \in B_3.
 \end{cases}
\end{equation}
\end_inset


\size default
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{table}[H]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
centering
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
caption{My caption}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
label{my-label}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{tabular}{l|lll}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  & $a 
\backslash
in B_1$ & $a 
\backslash
in B_2$ & $a 
\backslash
in B_3$ 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% $
\backslash
Delta_a$ & $
\backslash
mu_a - 
\backslash
mu_{m+1}$ & $
\backslash
mu_k - 
\backslash
mu_{m+1}$ & $
\backslash
mu_m - 
\backslash
mu_a$ 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{table}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

We note that 
\begin_inset Formula $\Delta_k = \Delta_{k+1} = \cdots = \Delta_m = \Delta_{m+1}$
\end_inset

. Let 
\begin_inset Formula $u^*(a,t) \defeq \bceil{\frac{32}{\max\{\Delta_a, \frac{\epsilon}{2}\}^2}\ln\frac{k_1 n t^4}{\delta}}$
\end_inset

 for all 
\begin_inset Formula $a \in \mathcal{A}$
\end_inset

, where 
\begin_inset Formula $k_1=5/4$
\end_inset

. Now, we define the hardness term as 
\begin_inset Formula $H_\epsilon = \sum_{a \in \mathcal{A}}\frac{1}{\max\{\Delta_a, \epsilon/2\}^2}$
\end_inset

.
\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
begin{restatable}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
{
\end_layout

\end_inset

theorem
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
{
\end_layout

\end_inset

thmscglucb
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset

[Expected Sample Complexity of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
GLUCB
\end_layout

\end_inset

] 
\begin_inset CommandInset label
LatexCommand label
name "thm:scglucb"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
GLUCB
\end_layout

\end_inset

 solves 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
QFK
\end_layout

\end_inset

 using an expected sample complexity upper bounded by 
\begin_inset Formula $O\left(H_\epsilon \log\frac{H_\epsilon}{\delta}\right)$
\end_inset

. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
end{restatable}
\end_layout

\end_inset

 Appendix-A describes the proof in detail. The core argument is similar to that for Algorithm 
\begin_inset Formula $\F_2$
\end_inset

 by 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\backslash
citet{bib:arcsk2017}
\end_layout

\end_inset

. However, it subtly differs due to the different strategy for choosing arms since the output set is not necessarily singleton. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  Recently, 
\backslash
citet{Jamieson+N:2014} has shown that using a 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% tailored upper bound, 
\backslash
LUCB can be shown to incur an expected sample complexity
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% which is within a $O(
\backslash
log n)$ factor of the lower bound. A similar technique can
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% also be adopted here to make a tighter analysis. However, in the interest of
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% keeping the proof simple, we keep our analysis restricted in the conventional approach and leave the tighter analysis as a future exercise. 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

In practice, one can use tighter confidence bound calculations (we use KL-divergence based confidence bounds in our experiments) to get even better sample complexity. 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% To analyse the sample complexity, first we define some events, at least
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% one of which must occur if the algorithm does not stop at the round $t$.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{definition}{(
\backslash
textsc{Probable Events})}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% Let $a, b 
\backslash
in 
\backslash
mathcal{A}$, such that $
\backslash
mu_a > 
\backslash
mu_b$. During the
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% run of the algorithm, any of the following five events may occur:
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% $CROSS_a^t 
\backslash
defeq 
\backslash
{ucb(a,t) < 
\backslash
mu_a 
\backslash
vee lcb(a,t) > 
\backslash
mu_a
\backslash
}$,
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% $ErrA(a,b,t)) 
\backslash
defeq 
\backslash
{
\backslash
hatp_a^t < 
\backslash
hatp_b^t
\backslash
}$,
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% $ErrL(a,b,t) 
\backslash
defeq 
\backslash
{lcb(a,t) < lcb(b,t)
\backslash
}$,
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% $ErrU(a,b,t) 
\backslash
defeq 
\backslash
{ucb(a,t) < ucb(b,t)
\backslash
}$,
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% $ NEEDY_a^t(d) 
\backslash
defeq 
\backslash
{
\backslash
{lcb(a,t) < 
\backslash
mu_a - d
\backslash
} 
\backslash
vee 
\backslash
{ucb(a,t) > 
\backslash
mu_a + d
\backslash
}
\backslash
}$.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{definition}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% We show that any arm $a$, if sampled sufficiently, that is $u_a^t 
\backslash
geq u^*(a,t)$, 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% then occurrence of any of the 
\backslash
textsc{Probable Events} imply occurrence of $CROSS_a^t$.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% First we show that if  $CROSS_a^t$ does not occur for any $a 
\backslash
in 
\backslash
A$, then occurrence
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% of any one of the 
\backslash
textsc{Probable Events} implies the occurrence of $NEEDY_a^t(
\backslash
cdot)$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% or $NEEDY_b^t(
\backslash
cdot)$.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% It is important to note that as $m_*^t$ is the least sampled arm in $A_2^t$,
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% for any arm $a 
\backslash
in A_2^t$, $NEEDY_a^t 
\backslash
implies NEEDY_{m_*^t}^t$.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{restatable}{lemma}{lemErrALUN}[Reducing Events To $NEEDY_a^t$]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
label{lem:ErrALUN}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% To prove that $
\backslash
{
\backslash
neg  CROSS_a^t 
\backslash
wedge 
\backslash
neg CROSS_b^t
\backslash
} 
\backslash
wedge 
\backslash
{ErrA(a,b,t) 
\backslash
vee ErrU(a,b,t) 
\backslash
vee ErrL(a,b,t)
\backslash
} 
\backslash
implies 
\backslash
{NEEDY_a^t(
\backslash
frac{
\backslash
Delta_{ab}}{2}) 
\backslash
vee NEEDY_b^t(
\backslash
frac{
\backslash
Delta_{ab}}{2}) 
\backslash
}$.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{restatable}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% We show that given a threshold $d$, if an arm $a$ is sufficiently sample such that $
\backslash
beta(u_a^t, t, 
\backslash
delta) 
\backslash
leq 
\backslash
frac{d}{2}$, then that $NEEDY_a^t$ infers $CROSS_a^t$.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{restatable}{lemma}{lemneedycross}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  
\backslash
label{lem:needycross}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%   For any $a 
\backslash
in 
\backslash
A$, $
\backslash
{NEEDY_a^t(d)|
\backslash
beta(u_a^t, t, 
\backslash
delta) < d/2
\backslash
} 
\backslash
implies CROSS_a^t$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{restatable}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% By the very definition of confidence bound, at any round $t$, the probability that
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% the empirical mean of an arm will lie outside it is very low. In other words, the
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% probability that $CROSS_a^t$ occur is very low for all $t$ and $a 
\backslash
in 
\backslash
A$.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{restatable}{lemma}{lemcross}[Upper bounding the probability of $CROSS_a^t$]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  
\backslash
label{lem:cross}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  $
\backslash
forall a 
\backslash
in 
\backslash
mathcal{A}$ and $
\backslash
forall t 
\backslash
geq 0$, $
\backslash
Pr
\backslash
{{CROSS_a^t}
\backslash
}  
\backslash
leq  
\backslash
frac{
\backslash
delta}{knt^4}$. Hence,
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  $P
\backslash
left[
\backslash
exists t 
\backslash
geq 0  
\backslash
wedge 
\backslash
exists a 
\backslash
in 
\backslash
mathcal{A} : {CROSS_a^t} | u_a^t 
\backslash
geq 0  
\backslash
right] 
\backslash
leq  
\backslash
frac{
\backslash
delta}{k_1 t^3}.$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{restatable}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{proof}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% $
\backslash
Pr
\backslash
{{CROSS_a^t}
\backslash
}$ is upper bounded by using Hoeffding's inequality, and the next statement
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% gets proved by taking union bound over all arms and $t$.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{proof}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% Now, recalling the definition of $h_*^t$, and $l_*^t$ from Algorithm~
\backslash
ref{alg:glucb},
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% we present the key logic underlying the analysis of 
\backslash
GLUCB. The idea is to show that
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% if the algorithm has not stopped, then one of those 
\backslash
textsc{Probable Events} must have
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% occurred. Then using Lemma~
\backslash
ref{lem:cross}, Lemma~
\backslash
ref{lem:ErrALUN},
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  and Lemma~
\backslash
ref{lem:needycross}, 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% we show that beyond a certain number of rounds, the probability that 
\backslash
GLUCB
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% will continue is upper bounded is sufficiently small.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% Lastly, using the argument based on pigeon-hole principle, similar to
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
citet[Lemma 5]{bib:shivaramphdthesis}, we establish the upper bound on the 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% sample complexity. The core logic to show that one of the probable events must occur until the algorithm stops is presented below.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{restatable}{lemma}{lemglucb_cases}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
label{lem:glucb_cases}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% If at 
\backslash
GLUCB has not stopped at round $t$, then for $a 
\backslash
in 
\backslash
{h_*^t, l_*^t
\backslash
}$, and $b 
\backslash
in 
\backslash
{h_*^t, l_*^t
\backslash
} 
\backslash
setminus 
\backslash
{a
\backslash
}$, one of the 
\backslash
textsc{Probable Events} must have occurred.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{restatable}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{proof}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% Recalling the definitions of the ground truth sets $B_1, B_2$ and $B_3$,
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% as $
\backslash
{h_*^t, l_*^t
\backslash
} 
\backslash
in B_1 
\backslash
cup B_2 
\backslash
cup B_3$, depending from which sets
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% out of these three, $h_*^t$, and $l_*^t$ have come, there are total $3 
\backslash
times 3 = 9$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% possible cases. 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% The detailed analysis of all the 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% cases is presented in the Appendix~
\backslash
ref{app:adaptive}.We present the case
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% where $h_*^t 
\backslash
in B_2 
\backslash
wedge l_*^t 
\backslash
in B_2$ in Figure~
\backslash
ref{fig:logicb2b2}. 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% Any arm in $B_2$ may belong to correct output set, but not mandatory. However, 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% one of the arms in $
\backslash
{h_*^t, l_*^t
\backslash
}$ can have mean arbitrarily close to the
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% worst arm in $B_1$, while the 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% other one's mean can be arbitrarily close to the best arm in $B_3$.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% On the other hand, as both $h_*^t$, and $l_*^t$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% belong to $B_2$, their means can be arbitrarily close, and hence, even if
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% $h_*^t$ and $l_*^t$ are sampled $u^*(h_*^t)$ and $u^*(l_*^t)$ times respectively,
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% $ ucb({l_*^t}, t+1) - lcb({h_*^t}, t+1) < 
\backslash
epsilon $ may not hold. 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% However, this will not occur as it will lead some other contradiction. 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% % This special
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% % properties of arms in $B_2$ makes this case the most interesting among all.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% % 
\backslash
fbox{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{figure}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
framebox[
\backslash
columnwidth][s]{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{minipage}[l][][l]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
flushleft
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  Suppose $h_*^t 
\backslash
in B_2 
\backslash
wedge l_*^t 
\backslash
in B_2$ and $
\backslash
Delta_{h_*^t l_*^t} > 0$.
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  Then, $
\backslash
exists b_1 
\backslash
in (A_2^t 
\backslash
cup A_3^t)
\backslash
cap B_1$ and $
\backslash
exists b_3 
\backslash
in (A_1^t 
\backslash
cup A_2^t)
\backslash
cap B_3$.
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% %   letting $
\backslash
mu_{h_*^t} > 
\backslash
mu_{l_*^t}$
\backslash
filler{WRONG!!!}
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%   
\backslash
If{$|
\backslash
Delta_{h_*^t l_*^t}| < 
\backslash
Delta_{h_*^t}/2$}{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     
\backslash
If{$
\backslash
Delta_{b_1 h_*^t} > 
\backslash
Delta_{b_1}/4$}{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       
\backslash
If{$b_1 
\backslash
in A_2^t )
\backslash
cap B_1$}{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $ErrA(b_1, h_*^t, t)$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       }
\backslash
Else{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $b_1 
\backslash
in A_3^t 
\backslash
cap B_1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $ErrU(b_1, l_*^t, t)$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     }
\backslash
Else{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       $
\backslash
Delta_{b_1 h_*^t} 
\backslash
leq 
\backslash
Delta_{b_1}/4$  and hence $
\backslash
Delta_{l_*^t b_3} 
\backslash
geq 
\backslash
Delta_{l_*^t}/4$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       
\backslash
If{$b_3 
\backslash
in A_2^t 
\backslash
cap B_3$}{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $ErrA(l_*^t, b_3, t)$  
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       }
\backslash
Else{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $b_3 
\backslash
in A_1^t 
\backslash
cap B_3$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $ErrL(h_*^t, b_3, t)$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%   }
\backslash
Else{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $|
\backslash
Delta_{h_*^t l_*^t}| > 
\backslash
Delta_{h_*^t}/2$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $$NEEDY_{h_*^t}^t (
\backslash
Delta_{h_*^t}/4) 
\backslash
vee NEEDY_{l_*^t}^t (
\backslash
Delta_{h_*^t}/4)$$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%   }
\backslash
par
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{minipage}%
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
hspace{2pt}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
vline
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
hspace{1pt}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{minipage}[r][][l]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  Suppose $h_*^t 
\backslash
in B_2 
\backslash
wedge l_*^t 
\backslash
in B_2$ and $
\backslash
Delta_{h_*^t l_*^t} 
\backslash
leq 0$.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%  Then, $
\backslash
exists b_1 
\backslash
in (A_2^t 
\backslash
cup A_3^t)
\backslash
cap B_1$ and $
\backslash
exists b_3 
\backslash
in (A_1^t 
\backslash
cup A_2^t)
\backslash
cap B_3$.
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% %   letting $
\backslash
mu_{h_*^t} > 
\backslash
mu_{l_*^t}$
\backslash
filler{WRONG!!!}
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%   
\backslash
If{$|
\backslash
Delta_{h_*^t l_*^t}| < 
\backslash
Delta_{h_*^t}/2$}{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     
\backslash
If{$
\backslash
Delta_{b_1 l_*^t} > 
\backslash
Delta_{b_1}/4$}{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       
\backslash
If{$b_1 
\backslash
in A_2^t )
\backslash
cap B_1$}{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $ErrA(b_1, h_*^t, t)$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       }
\backslash
Else{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $b_1 
\backslash
in A_3^t 
\backslash
cap B_1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $ErrU(b_1, l_*^t, t)$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     }
\backslash
Else{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       $
\backslash
Delta_{b_1 l_*^t} 
\backslash
leq 
\backslash
Delta_{b_1}/4$ and hence $
\backslash
Delta_{h_*^t b_3} 
\backslash
geq 
\backslash
Delta_{h_*^t}/4$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       
\backslash
If{$b_3 
\backslash
in A_2^t 
\backslash
cap B_3$}{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $ErrA(l_*^t, b_3, t)$  
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       }
\backslash
Else{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $b_3 
\backslash
in A_1^t 
\backslash
cap B_3$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $ErrL(h_*^t, b_3, t)$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%       }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%   }
\backslash
Else{
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $|
\backslash
Delta_{h_*^t l_*^t}| > 
\backslash
Delta_{h_*^t}/2$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%     $$NEEDY_{h_*^t}^t (
\backslash
Delta_{h_*^t}/4) 
\backslash
vee NEEDY_{l_*^t}^t (
\backslash
Delta_{h_*^t}/4)$$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
%   }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
caption{Shows that if 
\backslash
GLUCB does not stop and both $h_*^t$, $l_*^t 
\backslash
in B_2$,
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% then one of the 
\backslash
textsc{Probable Events} must have occurred. For the analysis of 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% all the cases vide Appendix~
\backslash
ref{app:adaptive}.}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
label{fig:logicb2b2}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{figure}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
begin{restatable}{corollary}{corgenubscglucb}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
label{cor:gen_ubsc_glucb}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% For any arm  $a 
\backslash
A$, our definition of $
\backslash
Delta_a$ coincides with the one
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% defined by 
\backslash
citet{bib:arcsk2017} for $k=1$, and for $k=m$ it coincides with
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% the one by 
\backslash
citet{bib:lucb}. As The hardness term $H_
\backslash
epsilon$ is the same
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% function of $
\backslash
Delta_a$ and $
\backslash
epsilon$, the upper bound on the sample complexity of
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
GLUCB matches with those for $
\backslash
F_2$ and 
\backslash
LUCB for $k=1$, and $k=m$ respectively.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
end{restatable}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% 
\backslash
GLUCB being an adaptive algorithm the sample complexity is dependent on the relative differences
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% of means of the arms. Next, we are going to present a non-adaptive algorithm that solves 
\backslash
QFK
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout
% with a number of samples that matches the lower bound up to a constant factor.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
